---
phase: 09-ux-security-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/LoadingSkeleton.tsx
  - frontend/src/components/ErrorAlert.tsx
  - frontend/src/components/EmptyState.tsx
  - frontend/src/pages/DashboardPage.tsx
  - frontend/src/pages/ContractsPage.tsx
  - frontend/src/pages/ReservationsPage.tsx
  - frontend/src/pages/AvailabilityPage.tsx
  - frontend/src/pages/PointChartsPage.tsx
  - frontend/src/pages/ScenarioPage.tsx
  - frontend/src/pages/TripExplorerPage.tsx
  - frontend/src/pages/SettingsPage.tsx
autonomous: true

must_haves:
  truths:
    - "Every page that loads data shows a skeleton or spinner while data is being fetched, not a plain text string"
    - "All error states show a styled alert with a clear message and a retry button"
    - "All pages with no data show an empty state with an icon, guidance text, and a call-to-action"
    - "Dashboard page shows an empty state when the user has zero contracts"
  artifacts:
    - path: "frontend/src/components/LoadingSkeleton.tsx"
      provides: "Reusable skeleton/spinner component with variant props for different page layouts"
    - path: "frontend/src/components/ErrorAlert.tsx"
      provides: "Reusable error alert component with retry button"
    - path: "frontend/src/components/EmptyState.tsx"
      provides: "Reusable empty state component with icon, message, and optional CTA button"
  key_links:
    - from: "frontend/src/pages/DashboardPage.tsx"
      to: "frontend/src/components/LoadingSkeleton.tsx"
      via: "import and render during isLoading state"
      pattern: "isLoading.*LoadingSkeleton|<LoadingSkeleton"
    - from: "frontend/src/pages/ContractsPage.tsx"
      to: "frontend/src/components/EmptyState.tsx"
      via: "import and render when contracts array is empty"
      pattern: "length === 0.*EmptyState|<EmptyState"
---

<objective>
Replace plain-text "Loading..." messages with animated skeleton placeholders, upgrade error states to styled alerts with retry, and ensure every page has a polished empty state.

Purpose: UX-01 (loading states), UX-02 (user-friendly errors), UX-04 (empty states) -- the app should feel responsive during loading, helpful during errors, and guiding when empty.

Output: 3 shared components (LoadingSkeleton, ErrorAlert, EmptyState) applied across all 8 page routes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@frontend/src/pages/DashboardPage.tsx
@frontend/src/pages/ContractsPage.tsx
@frontend/src/pages/ReservationsPage.tsx
@frontend/src/pages/AvailabilityPage.tsx
@frontend/src/pages/PointChartsPage.tsx
@frontend/src/pages/ScenarioPage.tsx
@frontend/src/pages/TripExplorerPage.tsx
@frontend/src/pages/SettingsPage.tsx
@frontend/src/components/ErrorBoundary.tsx
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared LoadingSkeleton, ErrorAlert, and EmptyState components</name>
  <files>
    frontend/src/components/LoadingSkeleton.tsx
    frontend/src/components/ErrorAlert.tsx
    frontend/src/components/EmptyState.tsx
  </files>
  <action>
    Create three reusable UI components using existing shadcn/ui primitives and Tailwind:

    **LoadingSkeleton.tsx:**
    - Accept a `variant` prop: "cards" (grid of skeleton cards for Dashboard, Contracts, Reservations), "table" (skeleton rows for PointCharts), "detail" (single block for Availability, Settings), "form" (for TripExplorer).
    - Each variant renders gray animated pulse blocks (`animate-pulse bg-muted rounded-md`) that approximate the layout of the real content.
    - "cards" variant: 3-4 skeleton cards in a responsive grid (matching the real card grid layout).
    - "table" variant: a skeleton table header + 5-6 skeleton rows.
    - "detail" variant: a single skeleton card with header and content area.
    - "form" variant: skeleton inputs + a skeleton results area below.
    - Use Tailwind's `animate-pulse` on `bg-muted` rounded divs. No external animation library.

    **ErrorAlert.tsx:**
    - Accept `message: string` and `onRetry?: () => void` props.
    - Render a Card with `border-destructive/50` styling, an AlertCircle icon from lucide-react, the error message in readable text (not raw JSON), and a "Try Again" Button that calls `onRetry` (hide button if no onRetry provided).
    - Use the existing Card component from @/components/ui/card and Button from @/components/ui/button.

    **EmptyState.tsx:**
    - Accept `icon?: LucideIcon`, `title: string`, `description: string`, `action?: { label: string; onClick: () => void }` props.
    - Render centered content inside a `py-12 border rounded-lg bg-muted/30` container (matching the existing empty state styling pattern in the codebase).
    - Show the icon (48px, text-muted-foreground), title (font-medium), description (text-muted-foreground text-sm), and optional action Button (variant="outline").
    - The icon prop should accept any lucide-react icon component.
  </action>
  <verify>
    Run `cd frontend && npx tsc --noEmit` -- zero TypeScript errors.
    Run `cd frontend && npm run build` -- build succeeds.
    Verify all 3 files exist and export default components.
  </verify>
  <done>
    Three reusable components exist: LoadingSkeleton with 4 variants, ErrorAlert with retry button, EmptyState with icon + CTA. All type-check and build cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace loading/error/empty states across all 8 pages</name>
  <files>
    frontend/src/pages/DashboardPage.tsx
    frontend/src/pages/ContractsPage.tsx
    frontend/src/pages/ReservationsPage.tsx
    frontend/src/pages/AvailabilityPage.tsx
    frontend/src/pages/PointChartsPage.tsx
    frontend/src/pages/ScenarioPage.tsx
    frontend/src/pages/TripExplorerPage.tsx
    frontend/src/pages/SettingsPage.tsx
  </files>
  <action>
    For each page, replace the existing loading/error/empty patterns with the shared components:

    **Loading states (replace `<p className="text-muted-foreground">Loading...</p>`):**
    - DashboardPage: `isLoading && <LoadingSkeleton variant="cards" />` (replacing "Loading dashboard...")
    - ContractsPage: `isLoading && <LoadingSkeleton variant="cards" />` (replacing "Loading contracts...")
    - ReservationsPage: `isLoading && <LoadingSkeleton variant="cards" />` (replacing "Loading reservations...")
    - AvailabilityPage: `isLoading && <LoadingSkeleton variant="detail" />` (replacing "Calculating availability...")
    - PointChartsPage: `chartsLoading && <LoadingSkeleton variant="table" />` (replacing "Loading available charts..." and "Loading chart data...")
    - SettingsPage: `isLoading && <LoadingSkeleton variant="detail" />` (replacing "Loading settings...")
    - TripExplorerPage: no loading state change needed (already has `isLoading` prop passed to form)
    - ScenarioPage: no standalone loading (contracts load inline)

    **Error states (replace `<p className="text-destructive">Failed to load...</p>`):**
    - For each page that has `{error && <p className="text-destructive">...}`, replace with:
      ```tsx
      {error && <ErrorAlert message={error.message} onRetry={() => refetch()} />}
      ```
    - This requires destructuring `refetch` from the useQuery hooks. Each hook (useContracts, useReservations, useAvailability, etc.) returns `refetch` from react-query -- destructure it alongside data/isLoading/error.
    - Pages needing refetch: DashboardPage (needs refetch from all 3 hooks -- use the first that errored, or a combined refetch), ContractsPage, ReservationsPage, AvailabilityPage, TripExplorerPage, SettingsPage.
    - For DashboardPage with multiple queries: use a combined refetch that calls all three: `const refetchAll = () => { refetchContracts(); refetchAvailability(); refetchReservations(); }`
    - SettingsPage: cast error properly (remove `as Error` cast, the error from react-query is already typed).
    - PointChartsPage: no explicit error state currently -- add one for `chartsLoading` failure case if the query has an error field.

    **Empty states (replace or add empty state patterns):**
    - DashboardPage: Currently shows nothing when loaded but all data is empty. Add an empty state when contracts is defined and has length 0:
      ```tsx
      {!isLoading && !error && contracts && contracts.length === 0 && (
        <EmptyState
          icon={LayoutDashboard}
          title="No contracts yet"
          description="Add your first DVC contract to see your dashboard overview."
          action={{ label: "Add Contract", onClick: () => navigate("/contracts") }}
        />
      )}
      ```
      Import `useNavigate` from react-router-dom and `LayoutDashboard` from lucide-react.
    - ContractsPage: Replace existing inline empty state div with `<EmptyState icon={FileText} title="No contracts yet" description="Add your first DVC contract to get started." action={{ label: "Add Contract", onClick: () => setFormOpen(true) }} />`
    - ReservationsPage: Replace existing inline empty state div with `<EmptyState icon={CalendarDays} title="No reservations yet" description="Add your first reservation to track your DVC bookings." action={{ label: "Add Reservation", onClick: () => setFormOpen(true) }} />`
    - AvailabilityPage: Replace existing inline empty state div with `<EmptyState icon={BarChart3} title="No contracts found" description="Add a contract first to see point availability." action={{ label: "Go to Contracts", onClick: () => navigate("/contracts") }} />`  Import useNavigate.
    - PointChartsPage: Replace existing inline empty state div with `<EmptyState icon={Table} title="No point charts available" description="Add chart JSON files to data/point_charts/ directory to browse point costs." />`
    - ScenarioPage: Already has a good empty state for no contracts. Keep it but use EmptyState component for consistency: `<EmptyState icon={FlaskConical} title="No contracts found" description="Add contracts first to model scenarios." action={{ label: "Go to Contracts", onClick: () => navigate("/contracts") }} />`
    - TripExplorerPage: Replace the "Select check-in and check-out dates" div with `<EmptyState icon={Search} title="Ready to explore" description="Select check-in and check-out dates above to see what you can book." />`
    - SettingsPage: No empty state needed (settings always have defaults).

    Import the appropriate lucide-react icons for each page's empty state.
  </action>
  <verify>
    Run `cd frontend && npx tsc --noEmit` -- zero TypeScript errors.
    Run `cd frontend && npm run build` -- build succeeds.
    Run `cd frontend && npx eslint .` -- zero warnings.
    Grep for old loading patterns: `grep -r "Loading contracts\|Loading dashboard\|Loading reservations\|Loading settings\|Calculating availability\|Loading available charts" frontend/src/pages/` should return NO results.
    Grep for old error patterns: `grep -r "text-destructive.*Failed to load" frontend/src/pages/` should return NO results.
  </verify>
  <done>
    All 8 pages use LoadingSkeleton for loading states (no plain text "Loading..." anywhere), ErrorAlert with retry for error states, and EmptyState with icons + guidance for empty data states. Dashboard shows empty state for zero contracts.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npm run build` succeeds
2. `cd frontend && npx tsc --noEmit` returns zero errors
3. `cd frontend && npx eslint .` returns zero warnings
4. No plain-text "Loading..." strings remain in page components
5. No raw `text-destructive` error paragraphs remain in page components
6. All pages with data queries have retry functionality on error
7. Dashboard page handles the zero-contracts case with a visible empty state
</verification>

<success_criteria>
- Every data-loading page shows animated skeleton placeholders while fetching
- Every error state shows a styled ErrorAlert card with a retry button
- Every empty-data state shows an EmptyState component with icon, message, and guidance
- Zero TypeScript errors, zero eslint warnings, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/09-ux-security-polish/09-01-SUMMARY.md`
</output>
