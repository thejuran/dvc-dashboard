---
phase: 08-code-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/ErrorBoundary.tsx
  - frontend/src/App.tsx
  - frontend/src/pages/DashboardPage.tsx
  - frontend/src/pages/TripExplorerPage.tsx
  - frontend/src/pages/ScenarioPage.tsx
  - frontend/src/pages/ContractsPage.tsx
  - frontend/src/pages/AvailabilityPage.tsx
  - frontend/src/pages/ReservationsPage.tsx
  - frontend/src/pages/PointChartsPage.tsx
  - frontend/src/pages/SettingsPage.tsx
  - frontend/src/components/ContractFormDialog.tsx
  - frontend/src/components/ReservationFormDialog.tsx
  - frontend/src/components/PointBalanceForm.tsx
  - frontend/src/components/ScenarioBookingForm.tsx
autonomous: true

must_haves:
  truths:
    - "A React component throwing an error does not crash the entire app -- the error boundary catches it and shows a recovery message"
    - "Per-section error boundaries isolate failures so a crash in one section doesn't take down others"
    - "Error boundary fallback shows styled card matching app design with 'Something went wrong in [section]' and retry button"
    - "Error boundaries log the error + component stack to browser console"
    - "Frontend form validation triggers on blur with inline red text below each invalid field"
    - "Date fields enforce business logic at form level: valid ranges, check_out after check_in, max 14 nights"
  artifacts:
    - path: "frontend/src/components/ErrorBoundary.tsx"
      provides: "Reusable React error boundary component with styled fallback and retry"
      min_lines: 40
    - path: "frontend/src/App.tsx"
      provides: "Routes wrapped with per-section error boundaries"
      contains: "ErrorBoundary"
    - path: "frontend/src/components/ContractFormDialog.tsx"
      provides: "Contract form with blur validation and inline errors"
      contains: "onBlur"
    - path: "frontend/src/components/ReservationFormDialog.tsx"
      provides: "Reservation form with blur validation and inline errors"
      contains: "onBlur"
  key_links:
    - from: "frontend/src/components/ErrorBoundary.tsx"
      to: "frontend/src/App.tsx"
      via: "wrapping each page route"
      pattern: "<ErrorBoundary"
    - from: "frontend/src/components/ContractFormDialog.tsx"
      to: "frontend/src/lib/api.ts"
      via: "mutation error handling shows field-level errors"
      pattern: "ApiError|fields"
---

<objective>
Add React error boundaries for crash isolation and implement frontend form validation with inline error display.

Purpose: A component crash should never white-screen the entire app. Forms should give instant validation feedback on blur (not just on submit). Per the user's locked decisions: per-section boundaries (not app-level), styled card fallback with retry button, blur-triggered validation with inline red text.

Output: ErrorBoundary component, per-section wrapping in App.tsx, form validation with blur handlers and inline errors in all form dialogs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-code-hardening/08-CONTEXT.md

@frontend/src/App.tsx
@frontend/src/components/ContractFormDialog.tsx
@frontend/src/components/ReservationFormDialog.tsx
@frontend/src/components/PointBalanceForm.tsx
@frontend/src/components/ScenarioBookingForm.tsx
@frontend/src/pages/DashboardPage.tsx
@frontend/src/pages/TripExplorerPage.tsx
@frontend/src/pages/ScenarioPage.tsx
@frontend/src/pages/ContractsPage.tsx
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorBoundary component and wrap all page sections</name>
  <files>frontend/src/components/ErrorBoundary.tsx, frontend/src/App.tsx</files>
  <action>
Create `frontend/src/components/ErrorBoundary.tsx` as a React class component (error boundaries require class components):

```tsx
import { Component, type ErrorInfo, type ReactNode } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";

interface Props {
  section: string;  // e.g., "Dashboard", "Trip Explorer"
  children: ReactNode;
}

interface State {
  hasError: boolean;
}
```

- `getDerivedStateFromError()` returns `{ hasError: true }`.
- `componentDidCatch(error, errorInfo)` logs `console.error(`[ErrorBoundary: ${this.props.section}]`, error, errorInfo.componentStack)`.
- `render()`: if `hasError`, return a styled Card (using shadcn/ui Card component to match app design):
  ```
  <Card className="border-destructive/50 bg-destructive/5">
    <CardContent className="flex flex-col items-center justify-center py-10 text-center">
      <p className="text-lg font-semibold text-destructive mb-2">
        Something went wrong in {section}
      </p>
      <p className="text-sm text-muted-foreground mb-4">
        An unexpected error occurred. You can try again or refresh the page.
      </p>
      <Button variant="outline" onClick={() => this.setState({ hasError: false })}>
        Try Again
      </Button>
    </CardContent>
  </Card>
  ```
  The "Try Again" button calls `setState({ hasError: false })` which remounts the children.
- Otherwise, render `this.props.children`.

Update `frontend/src/App.tsx`:
- Import `ErrorBoundary`.
- Wrap each page route's element with `<ErrorBoundary section="...">`:

```tsx
<Route path="/" element={<ErrorBoundary section="Dashboard"><DashboardPage /></ErrorBoundary>} />
<Route path="/trip-explorer" element={<ErrorBoundary section="Trip Explorer"><TripExplorerPage /></ErrorBoundary>} />
<Route path="/scenarios" element={<ErrorBoundary section="Scenarios"><ScenarioPage /></ErrorBoundary>} />
<Route path="/contracts" element={<ErrorBoundary section="Contracts"><ContractsPage /></ErrorBoundary>} />
<Route path="/availability" element={<ErrorBoundary section="Availability"><AvailabilityPage /></ErrorBoundary>} />
<Route path="/reservations" element={<ErrorBoundary section="Reservations"><ReservationsPage /></ErrorBoundary>} />
<Route path="/point-charts" element={<ErrorBoundary section="Point Charts"><PointChartsPage /></ErrorBoundary>} />
<Route path="/settings" element={<ErrorBoundary section="Settings"><SettingsPage /></ErrorBoundary>} />
```

No app-level boundary needed (per user decision -- per-section is sufficient).
  </action>
  <verify>
Run `cd /Users/julianamacbook/DVC/frontend && npx tsc --noEmit` -- no type errors.
Run `cd /Users/julianamacbook/DVC/frontend && npm run build` -- build succeeds.

Verify ErrorBoundary is used for all routes: `grep -c "ErrorBoundary" frontend/src/App.tsx` should be >= 8 (one per route).
  </verify>
  <done>ErrorBoundary component exists with styled card fallback and retry button. Every page route is wrapped with a per-section error boundary. A crash in one section shows recovery UI without affecting other sections.</done>
</task>

<task type="auto">
  <name>Task 2: Add form validation on blur with inline error display</name>
  <files>frontend/src/components/ContractFormDialog.tsx, frontend/src/components/ReservationFormDialog.tsx, frontend/src/components/PointBalanceForm.tsx, frontend/src/components/ScenarioBookingForm.tsx</files>
  <action>
Add client-side validation to all form components. Validation triggers on blur (when user leaves a field). Errors display as inline red text below each field. Per user decision: "belt-and-suspenders" -- frontend validates for instant UX, backend re-validates as safety net.

**Validation pattern for all forms:**

Add a `fieldErrors` state: `const [fieldErrors, setFieldErrors] = useState<Record<string, string>>({})`.

Create a `validateField(name: string, value: any)` function that returns an error string or empty string. Call it `onBlur` for each field. Update `fieldErrors` state.

Display errors below each field:
```tsx
{fieldErrors.fieldName && (
  <p className="text-xs text-destructive mt-1">{fieldErrors.fieldName}</p>
)}
```

On form submit, run ALL validations first. If any errors, set all fieldErrors and return early (don't submit).

Also: when a mutation fails and the error is an `ApiError` with fields, map server-side field errors into `fieldErrors` state so they display inline too. Import `ApiError` from `@/lib/api`.

**ContractFormDialog.tsx validation rules:**
- `homeResort`: required ("Home resort is required")
- `useYearMonth`: required ("Use year month is required")
- `annualPoints`: required, must be 1-2000 ("Annual points must be between 1 and 2,000")
- `name`: if provided, max 100 chars ("Name must be 100 characters or less")

**ReservationFormDialog.tsx validation rules:**
- `contractId`: required when creating ("Contract is required")
- `resort`: required ("Resort is required")
- `roomKey`: required ("Room type is required")
- `checkIn`: required ("Check-in date is required")
- `checkOut`: required, must be after checkIn ("Check-out must be after check-in"), max 14 nights ("Stay cannot exceed 14 nights")
- `pointsCost`: required, must be > 0 ("Points cost must be greater than 0"), max 4000 ("Points cost seems too high")

**PointBalanceForm.tsx validation rules:**
(Read the component first to understand its structure, then add validation for its fields)
- `useYear`: required, must be 2020-2035 ("Use year must be between 2020 and 2035")
- `points`: required, must be >= 0 ("Points must be 0 or more")
- `allocationType`: required ("Allocation type is required")

**ScenarioBookingForm.tsx validation rules:**
(Read the component first to understand its structure, then add validation for its fields)
- `contractId`: required ("Contract is required")
- `resort`: required ("Resort is required")
- `roomKey`: required ("Room type is required")
- `checkIn`: required ("Check-in date is required")
- `checkOut`: required, must be after checkIn ("Check-out must be after check-in"), max 14 nights ("Stay cannot exceed 14 nights")

For select-based fields (resort, room, contract), validation triggers when the field value changes (since selects don't have traditional blur). Use an `onValueChange` wrapper that also validates.

For date fields: validate on blur AND on change (since date pickers can be finicky with blur events).
  </action>
  <verify>
Run `cd /Users/julianamacbook/DVC/frontend && npx tsc --noEmit` -- no type errors.
Run `cd /Users/julianamacbook/DVC/frontend && npm run build` -- build succeeds.

Verify onBlur handlers exist: `grep -c "onBlur" frontend/src/components/ContractFormDialog.tsx` should be >= 1.
Verify error display exists: `grep -c "text-destructive" frontend/src/components/ContractFormDialog.tsx` should be >= 2.
  </verify>
  <done>All form components validate on blur with inline red error text below each invalid field. Date fields enforce business logic (valid ranges, check_out after check_in, max 14 nights). Server-side validation errors from ApiError.fields are also displayed inline. Forms validate all fields before submit.</done>
</task>

</tasks>

<verification>
1. ErrorBoundary exists and wraps all 8 page routes
2. Build succeeds without type errors
3. Contract form shows inline error when blurring past an empty required field
4. Reservation form shows "Check-out must be after check-in" when dates are wrong
5. A component crash (simulated with a throw in a component) shows the styled recovery card, not a white screen
6. Retry button remounts the component
</verification>

<success_criteria>
- Error boundary catches component errors per-section with styled fallback card and retry button
- Error boundary logs error + component stack to browser console
- All forms validate on blur with inline red text below each invalid field
- Date fields enforce full business logic at form level
- Server-side field errors map to inline display
- Frontend builds without type errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-code-hardening/08-03-SUMMARY.md`
</output>
