---
phase: 08-code-hardening
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - backend/api/contracts.py
  - backend/api/reservations.py
  - backend/api/points.py
  - backend/api/scenarios.py
  - backend/api/point_charts.py
  - backend/api/trip_explorer.py
  - backend/api/availability.py
  - backend/api/settings.py
  - backend/api/booking_windows.py
  - backend/api/schemas.py
autonomous: true

must_haves:
  truths:
    - "Submitting invalid data to any API endpoint produces a clear validation error with field-level detail, not a 500 or unhandled exception"
    - "All API inputs are validated and sanitized server-side before processing"
    - "Validation errors return ALL invalid fields at once, not fail-on-first"
    - "Date fields enforce business logic: valid ranges, use year boundaries, check_out after check_in, max 14 nights"
    - "String fields enforce type, required, and format constraints"
  artifacts:
    - path: "backend/api/schemas.py"
      provides: "Tightened Pydantic models with comprehensive validators"
      contains: "field_validator"
    - path: "backend/api/contracts.py"
      provides: "Contract endpoints with validation using custom exceptions"
      contains: "ValidationError"
    - path: "backend/api/reservations.py"
      provides: "Reservation endpoints with validation using custom exceptions"
      contains: "ValidationError"
    - path: "backend/api/scenarios.py"
      provides: "Scenario endpoints with validation using custom exceptions"
      contains: "ValidationError"
  key_links:
    - from: "backend/api/schemas.py"
      to: "backend/api/errors.py"
      via: "Pydantic validators raise ValueError which gets caught by handle_pydantic_validation"
      pattern: "raise ValueError"
    - from: "backend/api/*.py"
      to: "backend/api/errors.py"
      via: "route handlers raise custom exceptions"
      pattern: "from backend.api.errors import"
---

<objective>
Harden input validation across all backend API endpoints to ensure every input is validated and sanitized server-side.

Purpose: Close the gap between Pydantic's basic type validation and full business-logic validation. After this plan, no invalid data reaches the engine or database layer -- every bad input gets a clear, structured error response with field-level detail.

Output: Tightened Pydantic schemas, additional route-level validation, all using the structured error infrastructure from Plan 01.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-code-hardening/08-CONTEXT.md
@.planning/phases/08-code-hardening/08-01-SUMMARY.md

@backend/api/errors.py
@backend/api/schemas.py
@backend/api/contracts.py
@backend/api/reservations.py
@backend/api/points.py
@backend/api/scenarios.py
@backend/api/point_charts.py
@backend/api/settings.py
@backend/api/availability.py
@backend/api/booking_windows.py
@backend/api/trip_explorer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tighten Pydantic schema validators for all request models</name>
  <files>backend/api/schemas.py</files>
  <action>
Audit and harden every request model (Create/Update/Request schemas) in `backend/api/schemas.py`:

**ContractCreate / ContractUpdate:**
- `name`: if provided, strip whitespace, max 100 chars. Reject empty string after strip (null is OK).
- `annual_points`: already has gt=0, le=2000. Good.
- `home_resort` and `use_year_month`: already validated. Good.

**PointBalanceCreate:**
- `use_year`: already has ge=2020, le=2035. Good.
- `points`: already has ge=0. Add le=4000 (2x max annual points -- reasonable cap for banked+current).

**ReservationCreate / ReservationUpdate:**
- `check_in`: add validator -- must not be in the past (for create only; update can keep existing past dates). Actually, DVC reservations CAN be historical records. Skip past-date check -- user tracks completed trips too.
- `check_out`: already validated (after check_in, max 14 nights). Good.
- `points_cost`: already has gt=0. Add le=4000 reasonable cap.
- `confirmation_number`: if provided, strip whitespace, max 50 chars.
- `notes`: if provided, max 500 chars.
- `room_key`: add min_length=1 (already has it). Add max_length=100.
- `resort`: already validated against resort slugs. Good.

**PointCostRequest:**
- `resort`: add min_length=1, max_length=50.
- `room_key`: add min_length=1, max_length=100.
- `check_in` / `check_out`: these are strings -- add validator to confirm ISO date format. Add cross-field validator: check_out > check_in, max 14 nights.

**ReservationPreviewRequest:**
- `check_out`: already validated. Good.
- Add max 14 nights constraint (currently missing from this schema).

**HypotheticalBooking:**
- `check_out`: already validated. Good.
- Add `resort` min_length=1 and `room_key` min_length=1.

**ScenarioEvaluateRequest:**
- `hypothetical_bookings`: add max 10 items limit (per user decision from what-if scenarios: "up to 10"). Add validator: `if len(v) > 10: raise ValueError("Maximum 10 hypothetical bookings")`.

**AppSettingUpdate:**
- `value`: add max_length=50, strip whitespace.

For ALL string fields that accept user input: strip leading/trailing whitespace using a `@field_validator` with `mode="before"` or use Pydantic's `BeforeValidator`. This prevents " polynesian " from slipping through as an invalid resort.
  </action>
  <verify>
Run `python -m pytest tests/ -x -q` -- all existing tests pass.

Test manually:
- `curl -s -X POST /api/contracts/ -H 'Content-Type: application/json' -d '{"home_resort":"polynesian","use_year_month":6,"annual_points":0,"purchase_type":"resale"}' | python3 -m json.tool` -- should return VALIDATION_ERROR with field "annual_points".
- `curl -s -X POST /api/contracts/ -H 'Content-Type: application/json' -d '{"home_resort":"  ","use_year_month":6,"annual_points":160,"purchase_type":"resale"}' | python3 -m json.tool` -- should return VALIDATION_ERROR (empty after strip).
  </verify>
  <done>All Pydantic request models have comprehensive validation: string lengths, numeric ranges, date constraints, whitespace stripping, business logic checks. No invalid data reaches the engine or database.</done>
</task>

<task type="auto">
  <name>Task 2: Add route-level validation for business rules not covered by Pydantic</name>
  <files>backend/api/contracts.py, backend/api/reservations.py, backend/api/points.py, backend/api/scenarios.py, backend/api/point_charts.py, backend/api/trip_explorer.py, backend/api/availability.py, backend/api/settings.py, backend/api/booking_windows.py</files>
  <action>
Audit each route handler for validation gaps and ensure all use the custom exceptions from `backend/api/errors.py` (from Plan 01). Add field-level detail to all validation errors.

**contracts.py:**
- Already converted in Plan 01. Verify all raises use custom exceptions with field-level detail.

**reservations.py:**
- `create_reservation`: The resort eligibility check already exists. Ensure it raises `ValidationError` with `fields=[{"field": "resort", "issue": "..."}]`.
- `preview_reservation`: When `compute_booking_impact` returns an error dict, raise `ValidationError` with descriptive field detail instead of raw HTTPException.
- Verify `check_in`/`check_out` are validated at schema level (they are via Pydantic).

**points.py:**
- `create_point_balance`: The duplicate check raises 409 (should be `ConflictError` from Plan 01). The banked-points-exceed-annual and borrowing-limit checks should use `ValidationError` with fields: `[{"field": "points", "issue": "Banked points (X) cannot exceed annual points (Y)"}]`.
- `update_point_balance`: Same borrowing limit check -- use `ValidationError` with field detail.

**scenarios.py:**
- `evaluate_scenario`: Contract-not-found and resort-eligibility checks should use custom exceptions with field-level detail. Include the booking index in the field name: `{"field": "hypothetical_bookings[0].resort", "issue": "..."}`.

**point_charts.py:**
- `calculate_cost`: Date parsing, chart-not-found, room-key validation -- convert all to custom exceptions. Date parse failure: `ValidationError("Invalid date format", fields=[{"field": "check_in", "issue": "Use ISO format (YYYY-MM-DD)"}])`.
- Chart endpoints returning 404: use `NotFoundError`.

**trip_explorer.py:**
- `trip_explorer`: check_out <= check_in and >14 nights -- use `ValidationError` with field-level detail: `fields=[{"field": "check_out", "issue": "Must be after check_in"}]`.

**availability.py:**
- Currently has no explicit validation beyond FastAPI's query param parsing. Add: validate `target_date` is not absurdly far in the past or future (e.g., year < 2020 or year > 2040). Use `ValidationError` with `fields=[{"field": "target_date", "issue": "..."}]`.

**settings.py:**
- Unknown key and invalid value checks -- already well-validated. Convert to custom exceptions (from Plan 01).

**booking_windows.py:**
- `days` query param is already validated by FastAPI (ge=1, le=90). No additional validation needed.

For ALL routes: ensure no bare `HTTPException` remains. Search all files for `raise HTTPException` after changes -- should find zero occurrences in route files.
  </action>
  <verify>
Run `python -m pytest tests/ -x -q` -- all tests pass.

Search for any remaining HTTPException usage: `grep -rn "raise HTTPException" backend/api/` -- should return zero matches in route files (only `errors.py` handler for StarletteHTTPException should reference it).

Test edge cases:
- POST reservation with ineligible resort -> structured error with field detail
- POST point balance duplicate -> CONFLICT error
- POST scenario with 11 bookings -> VALIDATION_ERROR about max 10
  </verify>
  <done>All API endpoints use custom exceptions exclusively. Every validation error includes field-level detail. No HTTPException is raised directly in any route handler. All inputs validated and sanitized server-side before processing.</done>
</task>

</tasks>

<verification>
1. `grep -rn "raise HTTPException" backend/api/` returns zero matches in route files
2. All endpoints return structured errors: `{"error": {"type": "...", "message": "...", "fields": [...]}}`
3. Validation errors include field-level detail for every invalid field
4. Validation errors return ALL invalid fields at once (Pydantic's default behavior preserved by our handler)
5. All tests pass
</verification>

<success_criteria>
- Zero `raise HTTPException` in any API route file
- Every validation error response includes field-level detail array
- Business logic validation (resort eligibility, borrowing limits, date constraints) all produce structured errors
- String inputs are stripped and length-limited
- Numeric inputs have reasonable bounds
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-code-hardening/08-02-SUMMARY.md`
</output>
