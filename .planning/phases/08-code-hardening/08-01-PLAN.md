---
phase: 08-code-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/api/errors.py
  - backend/main.py
  - backend/api/schemas.py
  - frontend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "Every API endpoint returns errors in a consistent JSON structure with type, message, and optional fields array"
    - "Pydantic validation errors are intercepted and reformatted into the structured error shape"
    - "500/unexpected errors return generic 'Something went wrong' to client with detail only in server logs"
    - "No stack traces or internal details exposed in any error response"
    - "Frontend API layer parses structured errors and surfaces human-readable messages"
  artifacts:
    - path: "backend/api/errors.py"
      provides: "Custom exception classes and FastAPI exception handlers"
      min_lines: 60
    - path: "backend/main.py"
      provides: "Exception handlers registered on app"
      contains: "add_exception_handler"
    - path: "frontend/src/lib/api.ts"
      provides: "Updated error parsing for structured error shape"
      contains: "error.type"
  key_links:
    - from: "backend/api/errors.py"
      to: "backend/main.py"
      via: "exception handlers registered on app startup"
      pattern: "app\\.add_exception_handler"
    - from: "backend/api/errors.py"
      to: "all API route files"
      via: "custom exception classes replace HTTPException"
      pattern: "raise (NotFoundError|ValidationError|ConflictError)"
    - from: "frontend/src/lib/api.ts"
      to: "backend/api/errors.py"
      via: "parsing error.type and error.fields from response JSON"
      pattern: "error\\.type"
---

<objective>
Create the backend structured error handling infrastructure and update the frontend API layer to consume it.

Purpose: Every API error response must follow the locked decision format: `{ "error": { "type": "...", "message": "...", "fields": [...] } }`. This plan builds the foundation that all subsequent error/validation work depends on.

Output: Custom exception classes, FastAPI exception handlers that intercept all error types (HTTPException, Pydantic ValidationError, unhandled exceptions), and an updated frontend API client that parses the new shape.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-code-hardening/08-CONTEXT.md

@backend/main.py
@backend/api/schemas.py
@backend/api/contracts.py
@backend/api/reservations.py
@backend/api/points.py
@backend/api/scenarios.py
@backend/api/point_charts.py
@backend/api/settings.py
@backend/api/availability.py
@backend/api/booking_windows.py
@backend/api/trip_explorer.py
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend error infrastructure and wire into FastAPI</name>
  <files>backend/api/errors.py, backend/main.py</files>
  <action>
Create `backend/api/errors.py` with:

1. **Structured error response helper** -- a function `error_response(status_code, error_type, message, fields=None)` that returns a `JSONResponse` with body: `{"error": {"type": error_type, "message": message, "fields": fields or []}}`.

2. **Custom exception classes** (all inherit from a base `AppError`):
   - `ValidationError(message, fields=None)` -- maps to 422, type "VALIDATION_ERROR"
   - `NotFoundError(message)` -- maps to 404, type "NOT_FOUND"
   - `ConflictError(message)` -- maps to 409, type "CONFLICT"
   - `ServerError(message)` -- maps to 500, type "SERVER_ERROR" (but message is always "Something went wrong" in response; real message logged)

   Each has `status_code`, `error_type`, `message`, and optional `fields` attributes.

3. **Exception handlers** (functions that take `request, exc`):
   - `handle_app_error` -- catches `AppError` subclasses, returns structured error. For `ServerError`, log the real message with `logging.exception()` and return generic "Something went wrong".
   - `handle_http_exception` -- catches FastAPI's `HTTPException`, maps it to structured format. Map status codes: 404 -> NOT_FOUND, 409 -> CONFLICT, 422 -> VALIDATION_ERROR, others -> SERVER_ERROR. This handles any remaining HTTPException raises that haven't been converted yet.
   - `handle_pydantic_validation` -- catches Pydantic's `RequestValidationError`. Iterate `exc.errors()`, build a `fields` list of `{"field": loc_path, "issue": msg}` for each error. Return 422 VALIDATION_ERROR with all fields at once (not fail-on-first). The `loc_path` should be the last element of the `loc` tuple (the field name), not the full path with "body" prefix.
   - `handle_unhandled` -- catches `Exception`, logs with `logging.exception()`, returns 500 with generic "Something went wrong" (no stack trace, no internal details).

4. **In `backend/main.py`**, import and register all four handlers:
   ```python
   from backend.api.errors import handle_app_error, handle_http_exception, handle_pydantic_validation, handle_unhandled, AppError
   from fastapi.exceptions import RequestValidationError
   from starlette.exceptions import HTTPException as StarletteHTTPException

   app.add_exception_handler(AppError, handle_app_error)
   app.add_exception_handler(StarletteHTTPException, handle_http_exception)
   app.add_exception_handler(RequestValidationError, handle_pydantic_validation)
   app.add_exception_handler(Exception, handle_unhandled)
   ```

   Register these AFTER creating the app but BEFORE including routers.

5. **Convert existing HTTPException raises in ALL route files** to use the new custom exceptions:
   - `HTTPException(status_code=404, detail="Contract not found")` -> `raise NotFoundError("Contract not found")`
   - `HTTPException(status_code=422, detail="...")` -> `raise ValidationError("...", fields=[...])` where field-level detail is extractable
   - `HTTPException(status_code=409, detail="...")` -> `raise ConflictError("...")`
   - `HTTPException(status_code=400, detail="...")` -> `raise ValidationError("...")`

   Update imports in: `contracts.py`, `reservations.py`, `points.py`, `scenarios.py`, `point_charts.py`, `settings.py`, `trip_explorer.py`. Remove `HTTPException` imports where no longer needed.

   For validation errors that have field-level detail (e.g., "Resort 'X' is not eligible"), include the field name in the fields array: `raise ValidationError("Validation failed", fields=[{"field": "resort", "issue": "Resort 'X' is not eligible for this contract"}])`.
  </action>
  <verify>
Run `python -c "from backend.api.errors import AppError, ValidationError, NotFoundError, ConflictError, ServerError, handle_app_error, handle_http_exception, handle_pydantic_validation, handle_unhandled"` to confirm imports work.

Run existing tests: `cd /Users/julianamacbook/DVC && python -m pytest tests/ -x -q` -- all existing tests should still pass (the structured error body is a superset of the old behavior, but test assertions on status codes remain valid; tests that check `resp.json()["detail"]` will need updating -- see verify step below).

Manually test with curl:
- `curl -s http://localhost:8000/api/contracts/99999 | python3 -m json.tool` should return `{"error": {"type": "NOT_FOUND", "message": "Contract not found", "fields": []}}`
- `curl -s -X POST http://localhost:8000/api/contracts/ -H "Content-Type: application/json" -d '{"use_year_month": 5}' | python3 -m json.tool` should return `{"error": {"type": "VALIDATION_ERROR", "message": "...", "fields": [...]}}` with multiple field errors
  </verify>
  <done>All API endpoints return errors in the structured format `{"error": {"type": "...", "message": "...", "fields": [...]}}`. No HTTPException is directly raised in any route file. Pydantic validation errors are intercepted and reformatted. 500 errors return generic message only.</done>
</task>

<task type="auto">
  <name>Task 2: Update frontend API layer to parse structured errors</name>
  <files>frontend/src/lib/api.ts</files>
  <action>
Update the `request` function in `frontend/src/lib/api.ts` to parse the new structured error shape:

1. When `!res.ok`, attempt to parse the JSON response body.
2. If the body matches the structured shape (`body.error?.message` exists), use that:
   - Throw a custom error object (or extend Error) that includes `type` (string), `message` (string), and `fields` (array of `{field, issue}`).
   - The `.message` property of the thrown Error should be the human-readable `error.message` from the response.
3. Fall back to `detail` (for any edge case where old-style errors slip through) or `res.statusText`.

Create an `ApiError` class extending `Error` with properties:
```typescript
class ApiError extends Error {
  type: string;
  fields: Array<{ field: string; issue: string }>;
  status: number;

  constructor(message: string, type: string, fields: Array<{ field: string; issue: string }>, status: number) {
    super(message);
    this.name = "ApiError";
    this.type = type;
    this.fields = fields;
    this.status = status;
  }
}
```

Export `ApiError` so components can use `instanceof ApiError` to check for structured errors and access `.fields` for field-level error display.

The updated `request` function:
```typescript
async function request<T>(path: string, options?: RequestInit): Promise<T> {
  const res = await fetch(`${BASE_URL}${path}`, {
    headers: { "Content-Type": "application/json", ...options?.headers },
    ...options,
  });
  if (!res.ok) {
    const body = await res.json().catch(() => null);
    if (body?.error) {
      throw new ApiError(
        body.error.message || "API request failed",
        body.error.type || "UNKNOWN",
        body.error.fields || [],
        res.status
      );
    }
    // Fallback for non-structured errors
    const detail = body?.detail || res.statusText || "API request failed";
    throw new ApiError(
      typeof detail === "string" ? detail : "API request failed",
      "UNKNOWN",
      [],
      res.status
    );
  }
  if (res.status === 204) return undefined as T;
  return res.json();
}
```
  </action>
  <verify>
Run `cd /Users/julianamacbook/DVC/frontend && npx tsc --noEmit` to confirm no type errors.

Verify the export is accessible: `grep -n "export class ApiError" frontend/src/lib/api.ts` should match.
  </verify>
  <done>Frontend API layer throws `ApiError` instances with `type`, `message`, `fields`, and `status` properties. Existing error display (via `.message`) continues to work. Components can now access `.fields` for field-level error display.</done>
</task>

</tasks>

<verification>
1. Start the dev server and hit a non-existent contract: response body matches `{"error": {"type": "NOT_FOUND", ...}}`
2. POST invalid data to `/api/contracts/`: response body has `"type": "VALIDATION_ERROR"` with populated `fields` array containing all invalid fields at once
3. All existing tests pass (update any that assert on `resp.json()["detail"]` to check `resp.json()["error"]["message"]` instead)
4. No stack traces or internal paths appear in any error response
5. Frontend builds without type errors
</verification>

<success_criteria>
- Every API error response follows the locked format: `{ "error": { "type": "...", "message": "...", "fields": [...] } }`
- Error types are: VALIDATION_ERROR, NOT_FOUND, SERVER_ERROR, CONFLICT
- Pydantic validation errors return all invalid fields at once
- 500 errors show "Something went wrong" to client, real detail in server logs
- Frontend `ApiError` class provides typed access to error structure
</success_criteria>

<output>
After completion, create `.planning/phases/08-code-hardening/08-01-SUMMARY.md`
</output>
