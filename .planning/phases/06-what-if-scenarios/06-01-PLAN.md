---
phase: 06-what-if-scenarios
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/engine/scenario.py
  - backend/api/scenarios.py
  - backend/api/schemas.py
  - backend/main.py
  - tests/test_scenario.py
  - tests/test_api_scenarios.py
autonomous: true

must_haves:
  truths:
    - "Scenario engine correctly computes cumulative impact of multiple hypothetical bookings across contracts"
    - "Evaluation endpoint accepts a list of hypothetical bookings and returns baseline vs scenario availability per contract"
    - "Invalid resort/contract combinations return errors without crashing the evaluation"
  artifacts:
    - path: "backend/engine/scenario.py"
      provides: "compute_scenario_impact() pure function"
      exports: ["compute_scenario_impact"]
    - path: "backend/api/scenarios.py"
      provides: "POST /api/scenarios/evaluate endpoint"
      exports: ["router"]
    - path: "backend/api/schemas.py"
      provides: "HypotheticalBooking, ScenarioEvaluateRequest, ScenarioEvaluateResponse schemas"
      contains: "class ScenarioEvaluateRequest"
    - path: "tests/test_scenario.py"
      provides: "Engine unit tests for compute_scenario_impact"
      min_lines: 40
    - path: "tests/test_api_scenarios.py"
      provides: "Endpoint integration tests"
      min_lines: 40
  key_links:
    - from: "backend/engine/scenario.py"
      to: "backend/engine/availability.py"
      via: "get_contract_availability() calls"
      pattern: "get_contract_availability"
    - from: "backend/engine/scenario.py"
      to: "backend/data/point_charts.py"
      via: "calculate_stay_cost() for resolving hypotheticals"
      pattern: "calculate_stay_cost"
    - from: "backend/api/scenarios.py"
      to: "backend/engine/scenario.py"
      via: "compute_scenario_impact() call"
      pattern: "compute_scenario_impact"
    - from: "backend/api/scenarios.py"
      to: "backend/engine/eligibility.py"
      via: "get_eligible_resorts() for validation"
      pattern: "get_eligible_resorts"
---

<objective>
Build the scenario evaluation backend: a pure-function engine module that computes cumulative impact of multiple hypothetical bookings, plus a POST /api/scenarios/evaluate endpoint that wires DB data to the engine.

Purpose: Provides the computation backbone for SCEN-01 (add multiple bookings), SCEN-02 (cumulative impact), and SCEN-03 (baseline vs scenario comparison). The frontend (plans 02-03) will call this endpoint.

Output: backend/engine/scenario.py, backend/api/scenarios.py, schema additions to schemas.py, router registration in main.py, and comprehensive tests.
</objective>

<execution_context>
@.planning/phases/06-what-if-scenarios/06-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/engine/booking_impact.py
@backend/engine/availability.py
@backend/engine/eligibility.py
@backend/data/point_charts.py
@backend/api/reservations.py
@backend/api/schemas.py
@backend/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scenario engine + Pydantic schemas + tests</name>
  <files>
    backend/engine/scenario.py
    backend/api/schemas.py
    tests/test_scenario.py
  </files>
  <action>
    Create `backend/engine/scenario.py` with a `compute_scenario_impact()` pure function. This function:

    1. Accepts: contracts (list[dict]), point_balances (list[dict]), reservations (list[dict]), hypothetical_bookings (list[dict]), target_date (date).
    2. For each hypothetical booking, calls `calculate_stay_cost()` to resolve the point cost. If a booking's cost cannot be resolved (no chart data), add it to an `errors` list and skip it (do not crash).
    3. Computes baseline availability per contract using `get_contract_availability()` with only real reservations.
    4. Computes scenario availability per contract using `get_contract_availability()` with real reservations + ALL resolved hypotheticals injected as additional reservations (status "confirmed"). This ensures cumulative impact -- booking #2 sees the effect of booking #1.
    5. Returns a dict with:
       - `target_date` (ISO string)
       - `contracts`: list of per-contract results, each with contract_id, contract_name, home_resort, baseline (full availability dict), scenario (full availability dict), hypothetical_bookings (resolved ones for this contract)
       - `summary`: baseline_available (grand total), scenario_available (grand total), total_impact (baseline - scenario), num_hypothetical_bookings (count of resolved)
       - `resolved_bookings`: list of resolved hypothetical dicts (contract_id, resort, room_key, check_in, check_out, points_cost, num_nights)
       - `errors`: list of error dicts

    Follow the exact pattern from the research (Pattern 2), which mirrors how `compute_booking_impact()` works but for multiple bookings at once.

    Add Pydantic schemas to `backend/api/schemas.py` at the end of the file:
    - `HypotheticalBooking`: contract_id (int), resort (str), room_key (str), check_in (date_type), check_out (date_type). Add field_validator: check_out must be after check_in, stay cannot exceed 14 nights.
    - `ScenarioEvaluateRequest`: hypothetical_bookings (list[HypotheticalBooking])
    - `ContractScenarioResult`: contract_id, contract_name, home_resort, baseline_available, baseline_total, baseline_committed, scenario_available, scenario_total, scenario_committed, impact (int)
    - `ResolvedBooking`: contract_id, resort, room_key, check_in (date_type), check_out (date_type), points_cost, num_nights
    - `ScenarioEvaluateResponse`: contracts (list[ContractScenarioResult]), summary (dict), resolved_bookings (list[ResolvedBooking]), errors (list[dict])

    Create `tests/test_scenario.py` with unit tests for the engine function:
    - Test with single hypothetical booking: verify baseline != scenario, impact > 0
    - Test with multiple bookings on same contract: verify cumulative impact
    - Test with bookings across different contracts: verify each contract shows correct impact
    - Test with invalid booking (no point chart data): verify it goes to errors, other bookings still processed
    - Test with empty hypothetical_bookings list: verify baseline == scenario, zero impact
    - Test with cancelled reservation in real data: verify cancelled reservations excluded from baseline

    Use the same test fixture pattern as tests/test_booking_impact.py (mock get_contract_availability and calculate_stay_cost, or use real functions with test data).
  </action>
  <verify>
    Run `cd /Users/julianamacbook/DVC && python -m pytest tests/test_scenario.py -v` -- all tests pass.
    Run `python -c "from backend.engine.scenario import compute_scenario_impact; print('OK')"` -- import succeeds.
    Run `python -c "from backend.api.schemas import ScenarioEvaluateRequest, ScenarioEvaluateResponse; print('OK')"` -- import succeeds.
  </verify>
  <done>
    compute_scenario_impact() correctly produces baseline vs scenario availability for multiple hypothetical bookings across contracts. All engine tests pass. Schemas importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scenario evaluation endpoint + router registration + integration tests</name>
  <files>
    backend/api/scenarios.py
    backend/main.py
    tests/test_api_scenarios.py
  </files>
  <action>
    Create `backend/api/scenarios.py` with a `POST /api/scenarios/evaluate` endpoint:

    1. Accepts `ScenarioEvaluateRequest` body.
    2. Loads ALL contracts from DB.
    3. If no contracts exist, return 200 with empty results (not an error).
    4. For each hypothetical booking, validate resort eligibility: load the contract, call `get_eligible_resorts(contract.home_resort, contract.purchase_type)`, verify the booking's resort is in the eligible list. If not, return 422 with detail explaining which contract/resort combination is invalid.
    5. Load ALL point balances and ALL non-cancelled reservations from DB (same pattern as reservations.py preview_reservation).
    6. Convert ORM objects to dicts (same pattern as reservations.py lines 101-126).
    7. Call `compute_scenario_impact()` with today's date as target_date.
    8. Map the engine result to `ScenarioEvaluateResponse`, extracting baseline_available/total/committed and scenario_available/total/committed from each contract's availability dict.
    9. Return the response.

    Follow the endpoint pattern from `backend/api/reservations.py` (preview_reservation) for DB loading and ORM-to-dict conversion. Use `from datetime import date` and `date.today()` as target_date.

    Register the router in `backend/main.py`: import `from backend.api.scenarios import router as scenarios_router` and add `app.include_router(scenarios_router)` BEFORE the SPA mount (add it after the booking_windows_router line).

    Create `tests/test_api_scenarios.py` with integration tests (follow existing test patterns in tests/test_api_reservations.py):
    - Test evaluate with valid hypothetical booking: 200, response has contracts/summary/resolved_bookings/errors
    - Test evaluate with empty bookings list: 200, summary shows zero impact
    - Test evaluate with ineligible resort (resale contract trying restricted resort): 422
    - Test evaluate with missing contract_id: 422 (Pydantic validation or endpoint validation)
    - Test evaluate with check_out before check_in: 422 (Pydantic validation)
    - Test evaluate with multiple bookings: verify cumulative impact in summary.total_impact
  </action>
  <verify>
    Run `cd /Users/julianamacbook/DVC && python -m pytest tests/test_api_scenarios.py -v` -- all tests pass.
    Run `python -m pytest tests/ -v --tb=short` -- full test suite passes with no regressions.
    Run `curl -s http://localhost:8000/api/scenarios/evaluate -X POST -H "Content-Type: application/json" -d '{"hypothetical_bookings":[]}' | python -m json.tool` -- returns 200 with empty results (requires dev server running).
  </verify>
  <done>
    POST /api/scenarios/evaluate endpoint returns correct baseline vs scenario comparison. Resort eligibility enforced. Router registered. All integration tests pass. Full test suite green.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_scenario.py tests/test_api_scenarios.py -v` -- all scenario tests pass
- `python -m pytest tests/ -v --tb=short` -- full suite passes, no regressions
- `python -c "from backend.api.scenarios import router; print('Router OK')"` -- router importable
- Engine is pure: `backend/engine/scenario.py` has no DB imports (only imports from engine/ and data/)
</verification>

<success_criteria>
- compute_scenario_impact() computes cumulative impact of N hypothetical bookings across M contracts
- POST /api/scenarios/evaluate returns baseline vs scenario availability per contract with grand totals
- Invalid resort/contract combos return 422
- Point chart errors are captured in errors array without crashing
- All new tests pass, full suite green with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-what-if-scenarios/06-01-SUMMARY.md`
</output>
