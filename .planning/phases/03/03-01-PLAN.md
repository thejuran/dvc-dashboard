---
phase: 03-dashboard-trip-explorer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/engine/trip_explorer.py
  - backend/api/trip_explorer.py
  - backend/api/schemas.py
  - backend/main.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GET /api/trip-explorer?check_in=YYYY-MM-DD&check_out=YYYY-MM-DD returns affordable resort/room options"
    - "Results are filtered by resale eligibility per contract"
    - "Results only include options where total_points <= available_points"
    - "Response includes resorts_checked and resorts_skipped lists for transparency"
    - "Available points are calculated for the check_in date's use year, not today"
  artifacts:
    - path: "backend/engine/trip_explorer.py"
      provides: "Pure-function affordability calculator composing existing engine functions"
      exports: ["find_affordable_options"]
    - path: "backend/api/trip_explorer.py"
      provides: "GET /api/trip-explorer endpoint"
      exports: ["router"]
    - path: "backend/api/schemas.py"
      provides: "TripExplorerOption and TripExplorerResponse Pydantic schemas"
      contains: "class TripExplorerOption"
    - path: "backend/main.py"
      provides: "Trip explorer router registered"
      contains: "trip_explorer_router"
  key_links:
    - from: "backend/engine/trip_explorer.py"
      to: "backend/engine/availability.py"
      via: "get_contract_availability() call with check_in as target_date"
      pattern: "get_contract_availability.*target_date.*check_in"
    - from: "backend/engine/trip_explorer.py"
      to: "backend/engine/eligibility.py"
      via: "get_eligible_resorts() call per contract"
      pattern: "get_eligible_resorts"
    - from: "backend/engine/trip_explorer.py"
      to: "backend/data/point_charts.py"
      via: "calculate_stay_cost() call per resort/room combo"
      pattern: "calculate_stay_cost"
    - from: "backend/api/trip_explorer.py"
      to: "backend/engine/trip_explorer.py"
      via: "find_affordable_options() call"
      pattern: "find_affordable_options"
---

<objective>
Build the Trip Explorer backend: a new engine function and API endpoint that answers "what can I afford?" by composing existing availability, eligibility, and cost calculation functions.

Purpose: This is the only new backend work in Phase 3. The dashboard needs zero new endpoints, but the trip explorer requires server-side iteration over all eligible resorts/rooms to check affordability -- too much data for client-side computation.

Output: Working GET /api/trip-explorer endpoint that accepts check_in and check_out dates and returns all affordable resort/room options across all contracts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03/03-RESEARCH.md

@backend/engine/availability.py
@backend/engine/eligibility.py
@backend/data/point_charts.py
@backend/data/resorts.py
@backend/api/availability.py
@backend/api/schemas.py
@backend/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Trip Explorer engine function</name>
  <files>backend/engine/trip_explorer.py</files>
  <action>
Create `backend/engine/trip_explorer.py` with a single pure function `find_affordable_options()`.

**Signature:**
```python
def find_affordable_options(
    contracts: list[dict],
    point_balances: list[dict],
    reservations: list[dict],
    check_in: date,
    check_out: date,
) -> dict:
```

**Logic:**
1. Call `get_available_charts()` to get the set of resorts that have chart data for `check_in.year`.
2. Call `load_resorts()` to get resort slug-to-name mapping.
3. For each contract:
   a. Filter `point_balances` and `reservations` to this contract.
   b. Call `get_contract_availability()` with `target_date=check_in` (critical -- uses check_in date's use year for correct point calculation, NOT today's date).
   c. If `available_points <= 0`, skip this contract.
   d. Call `get_eligible_resorts(contract["home_resort"], contract["purchase_type"])`.
   e. For each eligible resort:
      - If resort not in `resorts_with_charts`, add to `resorts_skipped` set. Continue.
      - Add to `resorts_checked` set.
      - Load the point chart via `load_point_chart(resort_slug, check_in.year)`.
      - Collect all unique room_keys across all seasons in the chart.
      - For each room_key, call `calculate_stay_cost(resort_slug, room_key, check_in, check_out)`.
      - If cost_result is not None and `cost_result["total_points"] <= available_points`, append to results with: contract_id, contract_name, available_points, resort slug, resort name, room_key, total_points, num_nights, points_remaining (available - total_points), nightly_avg (total_points / num_nights rounded).
4. Sort results by `total_points` ascending (cheapest first).
5. Return dict with: check_in, check_out, num_nights, options (the results list), resorts_checked (sorted list), resorts_skipped (sorted list), total_options count.

**Import from existing modules:**
- `from backend.engine.availability import get_contract_availability`
- `from backend.engine.eligibility import get_eligible_resorts`
- `from backend.data.point_charts import calculate_stay_cost, get_available_charts, load_point_chart`
- `from backend.data.resorts import load_resorts`

**Do NOT:**
- Create a new availability calculation. Reuse `get_contract_availability()` exactly.
- Fetch from the database. This is a pure function that takes data as arguments (same pattern as `get_all_contracts_availability()`).
- Include nightly_breakdown in results (too verbose for a list of many options; user can use the existing /api/point-charts/calculate endpoint for breakdown).
  </action>
  <verify>
Run from project root:
```bash
cd /Users/julianamacbook/dvc && python -c "from backend.engine.trip_explorer import find_affordable_options; print('Import OK')"
```
Verify it imports without errors and has the expected function.
  </verify>
  <done>
`find_affordable_options()` exists, imports all existing engine/data functions, accepts contracts/balances/reservations/dates, returns dict with options list, resorts_checked, and resorts_skipped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Trip Explorer API endpoint and schemas</name>
  <files>backend/api/trip_explorer.py, backend/api/schemas.py, backend/main.py</files>
  <action>
**Step 1: Add Pydantic schemas to `backend/api/schemas.py`.**

Add at the end of the file:

```python
# Trip Explorer schemas

class TripExplorerOption(BaseModel):
    contract_id: int
    contract_name: str
    available_points: int
    resort: str
    resort_name: str
    room_key: str
    total_points: int
    num_nights: int
    points_remaining: int
    nightly_avg: int

class TripExplorerResponse(BaseModel):
    check_in: str
    check_out: str
    num_nights: int
    options: list[TripExplorerOption]
    resorts_checked: list[str]
    resorts_skipped: list[str]
    total_options: int
```

**Step 2: Create `backend/api/trip_explorer.py`.**

Follow the exact same pattern as `backend/api/availability.py`:
- Create `router = APIRouter(tags=["trip-explorer"])`
- Single GET endpoint at `/api/trip-explorer`
- Query params: `check_in: date` (required), `check_out: date` (required)
- Add validation: check_out must be after check_in, stay cannot exceed 14 nights. Return 422 with clear message if violated.
- Load all contracts, balances, and non-cancelled reservations from DB (same pattern as availability.py).
- Convert ORM objects to dicts (same pattern as availability.py).
- Call `find_affordable_options()` from the engine.
- Return the result (FastAPI auto-serializes the dict).

**Step 3: Register router in `backend/main.py`.**

Add import: `from backend.api.trip_explorer import router as trip_explorer_router`
Add: `app.include_router(trip_explorer_router)`

**Do NOT:**
- Create a POST endpoint. This is a read-only query, GET is correct.
- Add response_model to the endpoint decorator (the engine returns a dict that matches the schema; adding response_model would require exact match which complicates development).
  </action>
  <verify>
Start the backend and test the endpoint:
```bash
cd /Users/julianamacbook/dvc && python -m uvicorn backend.main:app --port 8000 &
sleep 2
curl -s "http://localhost:8000/api/trip-explorer?check_in=2026-03-15&check_out=2026-03-18" | python -m json.tool
kill %1
```

Expected: Returns JSON with check_in, check_out, num_nights, options array, resorts_checked, resorts_skipped, and total_options. If no contracts exist in DB, options will be empty but the structure should be correct.

Also verify validation:
```bash
curl -s "http://localhost:8000/api/trip-explorer?check_in=2026-03-18&check_out=2026-03-15" | python -m json.tool
```
Expected: 422 error about check_out before check_in.

Then run existing tests to confirm no regressions:
```bash
cd /Users/julianamacbook/dvc && python -m pytest tests/ -x -q
```
  </verify>
  <done>
GET /api/trip-explorer endpoint works: accepts check_in and check_out query params, validates date range, returns affordable options with resort coverage info. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from backend.engine.trip_explorer import find_affordable_options"` succeeds
2. `curl /api/trip-explorer?check_in=2026-03-15&check_out=2026-03-18` returns valid JSON response
3. Response contains: check_in, check_out, num_nights, options, resorts_checked, resorts_skipped, total_options
4. Invalid date range (check_out <= check_in) returns 422
5. Stay > 14 nights returns 422
6. All existing pytest tests pass (no regressions)
</verification>

<success_criteria>
- Trip explorer engine function composes existing availability, eligibility, and cost functions
- API endpoint accepts date range, returns affordable options sorted by cost
- Response clearly shows which resorts were checked vs skipped due to missing chart data
- Point availability uses check_in date (not today) for correct use year calculation
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/03/03-01-SUMMARY.md`
</output>
